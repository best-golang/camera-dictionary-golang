// Copyright 2017 Google Inc. All rights reserved.
// Use of this source code is governed by the Apache 2.0
// license that can be found in the LICENSE file.

// Command firestore_snippets contains runnable snippet code for Cloud Spanner.
package main
// go run main.go auth.go set.go word.go
import (
	//"fmt"
	"github.com/gin-gonic/gin"
	//"os"
	"golang.org/x/net/context"
	"cloud.google.com/go/firestore"

	//"os"
	"log"
	"github.com/golang/protobuf/ptypes/any"
)

// [START fs_class_definition]
// City represents a city.
type City struct {
	Name       string `firestore:"name,omitempty"`
	State      string `firestore:"state,omitempty"`
	Country    string `firestore:"country,omitempty"`
	Capital    bool   `firestore:"capital,omitempty"`
	Population int64  `firestore:"population,omitempty"`
}

type User struct {
	Username       string `firestore:"username,omitempty"`
	Password      string `firestore:"password,omitempty"`
}

type Set struct {
	Id       string `firestore:"-"`
	UserId       string `firestore:"user_id,omitempty"`
	Name      string `firestore:"name,omitempty"`
}

type Word struct {
	Id       string `firestore:"-"`
	SetId       string `firestore:"set_id,omitempty"`
	Type      string `firestore:"type,omitempty"`
	Content      string `firestore:"content,omitempty"`
	Language     string `firestore:"language,omitempty"`
	Translation      string `firestore:"translation,omitempty"`
	Pronunciation      string `firestore:"pronunciation,omitempty"`
}

type MyError struct {
	error
	Code int8
	Message string
	Details []any.Any
}
// [END fs_class_definition]

func main() {
	ctx := context.Background()

	//projectID := os.Getenv("GCLOUD_PROJECT")
	//if projectID == "" {
	//	log.Fatalf("Set Firebase project ID via GCLOUD_PROJECT env variable.")
	//}
	projectID := "calm-analogy-183605"
	client, err := firestore.NewClient(ctx, projectID)

	if err != nil {
		log.Fatalf("Cannot create client: %v", err)
	}

	router := gin.Default()

	auth := router.Group("/auth")
	{
		auth.POST("/login", func(c *gin.Context) {Login(c ,ctx ,client )})
		auth.POST("/register", func(c *gin.Context) {Register(c, ctx, client)})
	}
	api := router.Group("/api")
	{
		api.POST("/sets", func(c *gin.Context) {CreateSet(c ,ctx ,client )})
		api.GET("/sets", func(c *gin.Context) {ReadSets(c, ctx, client)})
		api.GET("/sets/:setId", func(c *gin.Context) {ReadSet(c, ctx, client)})
		api.PATCH("/sets/:setId", func(c *gin.Context) {UpdateSet(c, ctx, client)})
		api.DELETE("/sets/:setId", func(c *gin.Context) {DeleteSet(c, ctx, client)})

		api.POST("/words", func(c *gin.Context) {CreateWord(c ,ctx ,client )})
		api.GET("/words", func(c *gin.Context) {ReadWords(c, ctx, client)})
		api.GET("/words/:wordId", func(c *gin.Context) {ReadWord(c, ctx, client)})
		api.PATCH("/words/:wordId", func(c *gin.Context) {UpdateWord(c, ctx, client)})
		api.DELETE("/words/:wordId", func(c *gin.Context) {DeleteWord(c, ctx, client)})
	}
	router.Run()

	//defer client.Close()
	//
	//if err := prepareQuery(ctx, client); err != nil {
	//	log.Fatalf("Cannot prepare query docs: %v", err)
	//}
	//if err := addDocAsMap(ctx, client); err != nil {
	//	log.Fatalf("Cannot add document as map: %v", err)
	//}
	//if err := addDocDataTypes(ctx, client); err != nil {
	//	log.Fatalf("Cannot add document with more data types: %v", err)
	//}
	//if err := addDocAsEntity(ctx, client); err != nil {
	//	log.Fatalf("Cannot add document as entity: %v", err)
	//}
	//if err := addDocWithID(ctx, client); err != nil {
	//	log.Fatalf("Cannot add doc with id: %v", err)
	//}
	//if err := addDocWithoutID(ctx, client); err != nil {
	//	log.Fatalf("Cannot add doc without id: %v", err)
	//}
	//if err := addDocAfterAutoGeneratedID(ctx, client); err != nil {
	//	log.Fatalf("Cannot add document after generating ID: %v", err)
	//}
	//if err := updateDoc(ctx, client); err != nil {
	//	log.Fatalf("Cannot update doc: %v", err)
	//}
	//if err := updateDocCreateIfMissing(ctx, client); err != nil {
	//	log.Fatalf("Cannot update doc, creating if missing: %v", err)
	//}
	//if err := updateDocMultiple(ctx, client); err != nil {
	//	log.Fatalf("Cannot update multiple docs: %v", err)
	//}
	//if err := updateDocNested(ctx, client); err != nil {
	//	log.Fatalf("Cannot update nested doc: %v", err)
	//}
	//if err := deleteDoc(ctx, client); err != nil {
	//	log.Fatalf("Cannot delete doc: %v", err)
	//}
	//if err := deleteField(ctx, client); err != nil {
	//	log.Fatalf("Cannot delete document field: %v", err)
	//}
	//if err := runSimpleTransaction(ctx, client); err != nil {
	//	log.Fatalf("Cannot run simple job in transaction: %v", err)
	//}
	//if err := infoTransaction(ctx, client); err != nil {
	//	log.Fatalf("Cannot return info in transaction: %v", err)
	//}
	//if err := batchWrite(ctx, client); err != nil {
	//	log.Fatalf("Cannot write in a batch: %v", err)
	//}
	//if err := prepareRetrieve(ctx, client); err != nil {
	//	log.Fatalf("Cannot prepare for retrieve samples: %v", err)
	//}
	//if err := paginateCursor(ctx, client); err != nil {
	//	log.Fatalf("Cannot paginate cursor: %v", err)
	//}
	//
	//doc, err := docAsMap(ctx, client)
	//if err != nil {
	//	log.Fatalf("Cannot get doc as map: %v", err)
	//}
	//fmt.Printf("Retrieved doc as map: %v\n", doc)
	//
	//city, err := docAsEntity(ctx, client)
	//if err != nil {
	//	log.Fatalf("Cannot get doc as entity: %v", err)
	//}
	//fmt.Printf("Retrieved doc as entity: %v\n", city)
	//
	//if err := multipleDocs(ctx, client); err != nil {
	//	log.Fatalf("Cannot retrieve capital cities: %v", err)
	//}
	//if err := allDocs(ctx, client); err != nil {
	//	log.Fatalf("Cannot retrieve all docs: %v", err)
	//}
	//
	//if err := deleteCollection(ctx, client, client.Collection("cities"), 2); err != nil {
	//	log.Fatalf("Cannot delete collectionL %v", err)
	//}
}

// TODO(jbd): Add tests.

